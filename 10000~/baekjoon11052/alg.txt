f(n,k)

f(N, N) -> f(0, N) + P_N = P_N
     or f(N, N - 1)
f(N, N - 1) -> f(1, N - 1) + P_(N-1) -> f(1, N - 2) + P_(N-1) -> ... -> f(1, 1) + P_(N-1) = P_1 + P_(N-1)
            or f(N, N - 2)
...

n==0이면 다 샀으므로 종료
k==1이면 1짜리 팩을 n개 사는 방법 뿐이므로 n*P_1 반환

dp[n][k]: k개 이하가 들어있는 팩만으로 n개의 카드를 더 사야할 때 최대 비용


다른 사람 풀이:
a[k]: 카드 k개를 사는데 드는 최대 비용, 초기값은 P_k
2중 for문을 돌며 a[i]=max(a[i],a[j]+a[i-j-1])과 같이 업데이트