n*m에서 n, m 중 하나라도 홀수라면 모든 칸 통과 가능
모두 홀수이면 (r+c)%2==1인 점 한 개를 제외하고 모든 칸 통과 가능
(r+c)%2==0인 점 제외 시도시 (r+c)%2==1인 점 한 개 이상이 더 제외됨, 최소가 아님
string을 memoization 대상으로 하는 DP?
->사실 test case가 하나라 DP는 의미가 없다
(r+c)%2==1인 점 중 기쁨이 최소인 점을 찾은 뒤, 그 점을 지나지 않는 경로 찾기

n*m(n,m짝수)에서 구간을 1. (1,1)~(n,2), 2. (1,1)~(2,m), 3. (3,3)~(n,m)으로 분리
1., 2. 안에 최소인 점이 있으면 2*m 또는 n*2에서 그 칸을 회피하고 완료한 후, (n,3) 또는 (3,m)으로 간 뒤
(1,3) 또는 (3,1)로 가고, 마지막으로 (1,4) 또는 (4,1)로 가서 가능한 경우로 만든다
3. 안에 최소인 점이 있으면 (3,3)으로 간다

라고 생각했지만 사실 제외해야할 칸이 (1,2) 또는 (2,1)에 있을 때까지 판을 "축소"시킬 수 있다.
그러니까 그때까지 특정 이동들을 수행하여 2행씩, 2열씩 날려나가는 것이다.
그 다음에 그 칸을 회피하는 법은 코드에 적혀있다, 2행 또는 2열을 사용하여 회피한 뒤 그 다음 행 또는 열을 이용하여 왼쪽 위로 다시 돌아가는 것이 중요한 포인트
예외 처리가 꽤나 빡세다